CCS PCM C Compiler, Version 5.025, 51760               13-abr.-21 12:49

               Filename:   C:\Users\diego.gomez\Documents\Diego\Micros_avanzados\Microcontroladores_avanzados\Control temperatura\Picc\Temperatura.lst

               ROM used:   1706 words (21%)
                           Largest free fragment is 2048
               RAM used:   35 (10%) at main() level
                           61 (17%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   688
0003:  NOP
.................... #include <16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA D4,16
0005:  DATA 31,10
0006:  DATA 20,10
0007:  DATA 20,2A
0008:  DATA 2D,19
0009:  DATA 20,10
000A:  DATA 20,10
000B:  DATA D4,16
000C:  DATA 33,00
000D:  DATA 43,1D
000E:  DATA 25,26
000F:  DATA 64,10
0010:  DATA 20,10
0011:  DATA 43,1D
0012:  DATA 25,26
0013:  DATA 64,10
0014:  DATA 20,10
0015:  DATA 43,1D
0016:  DATA 25,26
0017:  DATA 64,00
0018:  DATA 54,1D
0019:  DATA 25,26
001A:  DATA 64,10
001B:  DATA 20,10
001C:  DATA 54,1D
001D:  DATA 25,26
001E:  DATA 64,10
001F:  DATA 20,10
0020:  DATA 54,1D
0021:  DATA 25,26
0022:  DATA 64,00
*
009E:  MOVLW  8E
009F:  MOVWF  77
00A0:  MOVF   3F,W
00A1:  MOVWF  78
00A2:  MOVF   3E,W
00A3:  MOVWF  79
00A4:  CLRF   7A
00A5:  MOVF   78,F
00A6:  BTFSS  03.2
00A7:  GOTO   0B2
00A8:  MOVF   79,W
00A9:  MOVWF  78
00AA:  CLRF   79
00AB:  MOVLW  08
00AC:  SUBWF  77,F
00AD:  MOVF   78,F
00AE:  BTFSS  03.2
00AF:  GOTO   0B2
00B0:  CLRF   77
00B1:  GOTO   0BA
00B2:  BCF    03.0
00B3:  BTFSC  78.7
00B4:  GOTO   0B9
00B5:  RLF    79,F
00B6:  RLF    78,F
00B7:  DECF   77,F
00B8:  GOTO   0B2
00B9:  BCF    78.7
00BA:  RETURN
00BB:  MOVF   4B,W
00BC:  BTFSC  03.2
00BD:  GOTO   12B
00BE:  MOVWF  53
00BF:  MOVF   4F,W
00C0:  BTFSC  03.2
00C1:  GOTO   12B
00C2:  ADDWF  53,F
00C3:  BTFSC  03.0
00C4:  GOTO   0CC
00C5:  MOVLW  7F
00C6:  SUBWF  53,F
00C7:  BTFSS  03.0
00C8:  GOTO   12B
00C9:  BTFSC  03.2
00CA:  GOTO   12B
00CB:  GOTO   0D0
00CC:  MOVLW  81
00CD:  ADDWF  53,F
00CE:  BTFSC  03.0
00CF:  GOTO   12B
00D0:  MOVF   53,W
00D1:  MOVWF  77
00D2:  CLRF   78
00D3:  CLRF   79
00D4:  CLRF   7A
00D5:  MOVF   4C,W
00D6:  MOVWF  57
00D7:  BSF    57.7
00D8:  MOVF   4D,W
00D9:  MOVWF  56
00DA:  MOVF   4E,W
00DB:  MOVWF  55
00DC:  MOVLW  18
00DD:  MOVWF  53
00DE:  CLRF   54
00DF:  BTFSS  55.0
00E0:  GOTO   0F9
00E1:  MOVF   52,W
00E2:  ADDWF  7A,F
00E3:  BTFSS  03.0
00E4:  GOTO   0EB
00E5:  INCF   79,F
00E6:  BTFSS  03.2
00E7:  GOTO   0EB
00E8:  INCF   78,F
00E9:  BTFSC  03.2
00EA:  BSF    54.7
00EB:  MOVF   51,W
00EC:  ADDWF  79,F
00ED:  BTFSS  03.0
00EE:  GOTO   0F2
00EF:  INCF   78,F
00F0:  BTFSC  03.2
00F1:  BSF    54.7
00F2:  MOVF   50,W
00F3:  MOVWF  4D
00F4:  BSF    4D.7
00F5:  MOVF   4D,W
00F6:  ADDWF  78,F
00F7:  BTFSC  03.0
00F8:  BSF    54.7
00F9:  RLF    54,F
00FA:  RRF    78,F
00FB:  RRF    79,F
00FC:  RRF    7A,F
00FD:  RRF    57,F
00FE:  RRF    56,F
00FF:  RRF    55,F
0100:  BCF    03.0
0101:  DECFSZ 53,F
0102:  GOTO   0DE
0103:  MOVLW  01
0104:  ADDWF  77,F
0105:  BTFSC  03.0
0106:  GOTO   12B
0107:  BTFSC  78.7
0108:  GOTO   110
0109:  RLF    57,F
010A:  RLF    7A,F
010B:  RLF    79,F
010C:  RLF    78,F
010D:  DECF   77,F
010E:  BTFSC  03.2
010F:  GOTO   12B
0110:  BTFSS  57.7
0111:  GOTO   121
0112:  INCF   7A,F
0113:  BTFSS  03.2
0114:  GOTO   121
0115:  INCF   79,F
0116:  BTFSS  03.2
0117:  GOTO   121
0118:  INCF   78,F
0119:  BTFSS  03.2
011A:  GOTO   121
011B:  RRF    78,F
011C:  RRF    79,F
011D:  RRF    7A,F
011E:  INCF   77,F
011F:  BTFSC  03.2
0120:  GOTO   12B
0121:  MOVF   4C,W
0122:  MOVWF  54
0123:  MOVF   50,W
0124:  XORWF  54,F
0125:  BTFSS  54.7
0126:  GOTO   129
0127:  BSF    78.7
0128:  GOTO   12F
0129:  BCF    78.7
012A:  GOTO   12F
012B:  CLRF   77
012C:  CLRF   78
012D:  CLRF   79
012E:  CLRF   7A
012F:  RETURN
0130:  MOVF   42,W
0131:  BTFSC  03.2
0132:  GOTO   1F5
0133:  MOVWF  4E
0134:  MOVF   46,W
0135:  BTFSC  03.2
0136:  GOTO   1F5
0137:  SUBWF  4E,F
0138:  BTFSS  03.0
0139:  GOTO   13F
013A:  MOVLW  7F
013B:  ADDWF  4E,F
013C:  BTFSC  03.0
013D:  GOTO   1F5
013E:  GOTO   145
013F:  MOVLW  81
0140:  SUBWF  4E,F
0141:  BTFSS  03.0
0142:  GOTO   1F5
0143:  BTFSC  03.2
0144:  GOTO   1F5
0145:  MOVF   4E,W
0146:  MOVWF  77
0147:  CLRF   78
0148:  CLRF   79
0149:  CLRF   7A
014A:  CLRF   4D
014B:  MOVF   43,W
014C:  MOVWF  4C
014D:  BSF    4C.7
014E:  MOVF   44,W
014F:  MOVWF  4B
0150:  MOVF   45,W
0151:  MOVWF  4A
0152:  MOVLW  19
0153:  MOVWF  4E
0154:  MOVF   49,W
0155:  SUBWF  4A,F
0156:  BTFSC  03.0
0157:  GOTO   168
0158:  MOVLW  01
0159:  SUBWF  4B,F
015A:  BTFSC  03.0
015B:  GOTO   168
015C:  SUBWF  4C,F
015D:  BTFSC  03.0
015E:  GOTO   168
015F:  SUBWF  4D,F
0160:  BTFSC  03.0
0161:  GOTO   168
0162:  INCF   4D,F
0163:  INCF   4C,F
0164:  INCF   4B,F
0165:  MOVF   49,W
0166:  ADDWF  4A,F
0167:  GOTO   19A
0168:  MOVF   48,W
0169:  SUBWF  4B,F
016A:  BTFSC  03.0
016B:  GOTO   183
016C:  MOVLW  01
016D:  SUBWF  4C,F
016E:  BTFSC  03.0
016F:  GOTO   183
0170:  SUBWF  4D,F
0171:  BTFSC  03.0
0172:  GOTO   183
0173:  INCF   4D,F
0174:  INCF   4C,F
0175:  MOVF   48,W
0176:  ADDWF  4B,F
0177:  MOVF   49,W
0178:  ADDWF  4A,F
0179:  BTFSS  03.0
017A:  GOTO   19A
017B:  INCF   4B,F
017C:  BTFSS  03.2
017D:  GOTO   19A
017E:  INCF   4C,F
017F:  BTFSS  03.2
0180:  GOTO   19A
0181:  INCF   4D,F
0182:  GOTO   19A
0183:  MOVF   47,W
0184:  IORLW  80
0185:  SUBWF  4C,F
0186:  BTFSC  03.0
0187:  GOTO   199
0188:  MOVLW  01
0189:  SUBWF  4D,F
018A:  BTFSC  03.0
018B:  GOTO   199
018C:  INCF   4D,F
018D:  MOVF   47,W
018E:  IORLW  80
018F:  ADDWF  4C,F
0190:  MOVF   48,W
0191:  ADDWF  4B,F
0192:  BTFSS  03.0
0193:  GOTO   177
0194:  INCF   4C,F
0195:  BTFSS  03.2
0196:  GOTO   177
0197:  INCF   4D,F
0198:  GOTO   177
0199:  BSF    7A.0
019A:  DECFSZ 4E,F
019B:  GOTO   19D
019C:  GOTO   1A8
019D:  BCF    03.0
019E:  RLF    4A,F
019F:  RLF    4B,F
01A0:  RLF    4C,F
01A1:  RLF    4D,F
01A2:  BCF    03.0
01A3:  RLF    7A,F
01A4:  RLF    79,F
01A5:  RLF    78,F
01A6:  RLF    4F,F
01A7:  GOTO   154
01A8:  BTFSS  4F.0
01A9:  GOTO   1B0
01AA:  BCF    03.0
01AB:  RRF    78,F
01AC:  RRF    79,F
01AD:  RRF    7A,F
01AE:  RRF    4F,F
01AF:  GOTO   1B3
01B0:  DECF   77,F
01B1:  BTFSC  03.2
01B2:  GOTO   1F5
01B3:  BTFSC  4F.7
01B4:  GOTO   1DC
01B5:  BCF    03.0
01B6:  RLF    4A,F
01B7:  RLF    4B,F
01B8:  RLF    4C,F
01B9:  RLF    4D,F
01BA:  MOVF   49,W
01BB:  SUBWF  4A,F
01BC:  BTFSC  03.0
01BD:  GOTO   1C8
01BE:  MOVLW  01
01BF:  SUBWF  4B,F
01C0:  BTFSC  03.0
01C1:  GOTO   1C8
01C2:  SUBWF  4C,F
01C3:  BTFSC  03.0
01C4:  GOTO   1C8
01C5:  SUBWF  4D,F
01C6:  BTFSS  03.0
01C7:  GOTO   1EB
01C8:  MOVF   48,W
01C9:  SUBWF  4B,F
01CA:  BTFSC  03.0
01CB:  GOTO   1D3
01CC:  MOVLW  01
01CD:  SUBWF  4C,F
01CE:  BTFSC  03.0
01CF:  GOTO   1D3
01D0:  SUBWF  4D,F
01D1:  BTFSS  03.0
01D2:  GOTO   1EB
01D3:  MOVF   47,W
01D4:  IORLW  80
01D5:  SUBWF  4C,F
01D6:  BTFSC  03.0
01D7:  GOTO   1DC
01D8:  MOVLW  01
01D9:  SUBWF  4D,F
01DA:  BTFSS  03.0
01DB:  GOTO   1EB
01DC:  INCF   7A,F
01DD:  BTFSS  03.2
01DE:  GOTO   1EB
01DF:  INCF   79,F
01E0:  BTFSS  03.2
01E1:  GOTO   1EB
01E2:  INCF   78,F
01E3:  BTFSS  03.2
01E4:  GOTO   1EB
01E5:  INCF   77,F
01E6:  BTFSC  03.2
01E7:  GOTO   1F5
01E8:  RRF    78,F
01E9:  RRF    79,F
01EA:  RRF    7A,F
01EB:  MOVF   43,W
01EC:  MOVWF  4E
01ED:  MOVF   47,W
01EE:  XORWF  4E,F
01EF:  BTFSS  4E.7
01F0:  GOTO   1F3
01F1:  BSF    78.7
01F2:  GOTO   1F9
01F3:  BCF    78.7
01F4:  GOTO   1F9
01F5:  CLRF   77
01F6:  CLRF   78
01F7:  CLRF   79
01F8:  CLRF   7A
01F9:  RETURN
01FA:  MOVLW  8E
01FB:  MOVWF  77
01FC:  MOVF   3E,W
01FD:  SUBWF  77,F
01FE:  MOVF   3F,W
01FF:  MOVWF  79
0200:  MOVF   40,W
0201:  MOVWF  78
0202:  BSF    79.7
0203:  MOVF   77,F
0204:  BTFSC  03.2
0205:  GOTO   211
0206:  BCF    03.0
0207:  MOVF   79,F
0208:  BTFSS  03.2
0209:  GOTO   20D
020A:  MOVF   78,F
020B:  BTFSC  03.2
020C:  GOTO   211
020D:  RRF    79,F
020E:  RRF    78,F
020F:  DECFSZ 77,F
0210:  GOTO   206
0211:  BTFSS  3F.7
0212:  GOTO   218
0213:  COMF   78,F
0214:  COMF   79,F
0215:  INCF   78,F
0216:  BTFSC  03.2
0217:  INCF   79,F
0218:  RETURN
*
024F:  CLRF   46
0250:  MOVF   04,W
0251:  MOVWF  45
0252:  BCF    46.0
0253:  BTFSC  03.7
0254:  BSF    46.0
0255:  BTFSS  3F.7
0256:  GOTO   25F
0257:  BSF    45.7
0258:  BTFSS  45.4
0259:  INCF   45,F
025A:  COMF   3E,F
025B:  COMF   3F,F
025C:  INCF   3E,F
025D:  BTFSC  03.2
025E:  INCF   3F,F
025F:  SWAPF  3F,W
0260:  IORLW  F0
0261:  MOVWF  41
0262:  ADDWF  41,F
0263:  ADDLW  E2
0264:  MOVWF  42
0265:  ADDLW  32
0266:  MOVWF  44
0267:  MOVF   3F,W
0268:  ANDLW  0F
0269:  ADDWF  42,F
026A:  ADDWF  42,F
026B:  ADDWF  44,F
026C:  ADDLW  E9
026D:  MOVWF  43
026E:  ADDWF  43,F
026F:  ADDWF  43,F
0270:  SWAPF  3E,W
0271:  ANDLW  0F
0272:  ADDWF  43,F
0273:  ADDWF  44,F
0274:  RLF    43,F
0275:  RLF    44,F
0276:  COMF   44,F
0277:  RLF    44,F
0278:  MOVF   3E,W
0279:  ANDLW  0F
027A:  ADDWF  44,F
027B:  RLF    41,F
027C:  MOVLW  07
027D:  MOVWF  40
027E:  MOVLW  0A
027F:  ADDWF  44,F
0280:  DECF   43,F
0281:  BTFSS  03.0
0282:  GOTO   27F
0283:  ADDWF  43,F
0284:  DECF   42,F
0285:  BTFSS  03.0
0286:  GOTO   283
0287:  ADDWF  42,F
0288:  DECF   41,F
0289:  BTFSS  03.0
028A:  GOTO   287
028B:  ADDWF  41,F
028C:  DECF   40,F
028D:  BTFSS  03.0
028E:  GOTO   28B
028F:  MOVLW  40
0290:  MOVWF  04
0291:  BCF    03.7
0292:  MOVLW  07
0293:  ANDWF  45,W
0294:  BCF    45.6
0295:  DECF   04,F
0296:  ANDWF  45,W
0297:  BTFSS  03.2
0298:  GOTO   2A0
0299:  BTFSC  45.4
029A:  INCF   04,F
029B:  BTFSC  45.4
029C:  GOTO   2A0
029D:  MOVLW  20
029E:  MOVWF  77
029F:  GOTO   2BD
02A0:  ADDWF  04,F
02A1:  MOVLW  44
02A2:  SUBWF  04,W
02A3:  BTFSC  03.2
02A4:  BSF    45.6
02A5:  MOVF   00,W
02A6:  MOVWF  77
02A7:  BTFSS  03.2
02A8:  GOTO   2B1
02A9:  BTFSC  45.6
02AA:  GOTO   2B1
02AB:  BTFSC  45.4
02AC:  GOTO   2CB
02AD:  BTFSC  45.3
02AE:  GOTO   2B1
02AF:  MOVLW  20
02B0:  GOTO   2BC
02B1:  BTFSS  45.7
02B2:  GOTO   2B9
02B3:  MOVLW  2D
02B4:  MOVWF  77
02B5:  DECF   04,F
02B6:  BCF    45.6
02B7:  BCF    45.7
02B8:  GOTO   2BD
02B9:  BSF    45.3
02BA:  BCF    45.4
02BB:  MOVLW  30
02BC:  ADDWF  77,F
02BD:  CLRF   3F
02BE:  MOVF   04,W
02BF:  MOVWF  3E
02C0:  BCF    3F.0
02C1:  BTFSC  03.7
02C2:  BSF    3F.0
02C3:  MOVF   77,W
02C4:  MOVWF  4B
02C5:  CALL   22B
02C6:  MOVF   3E,W
02C7:  MOVWF  04
02C8:  BCF    03.7
02C9:  BTFSC  3F.0
02CA:  BSF    03.7
02CB:  INCF   04,F
02CC:  BTFSS  45.6
02CD:  GOTO   2A1
02CE:  RETURN
02CF:  MOVF   0B,W
02D0:  MOVWF  3F
02D1:  BCF    0B.7
02D2:  BSF    03.5
02D3:  BSF    03.6
02D4:  BSF    0C.7
02D5:  BSF    0C.0
02D6:  NOP
02D7:  NOP
02D8:  BCF    03.5
02D9:  BCF    03.6
02DA:  BTFSC  3F.7
02DB:  BSF    0B.7
02DC:  BTFSC  03.0
02DD:  GOTO   306
02DE:  BSF    03.6
02DF:  MOVF   0C,W
02E0:  ANDLW  7F
02E1:  BCF    03.6
02E2:  MOVWF  3F
02E3:  BSF    03.6
02E4:  MOVF   0D,W
02E5:  BCF    03.6
02E6:  MOVWF  40
02E7:  BSF    03.6
02E8:  MOVF   0F,W
02E9:  BCF    03.6
02EA:  MOVWF  41
02EB:  MOVF   3F,W
02EC:  MOVWF  4B
02ED:  CALL   22B
02EE:  MOVF   40,W
02EF:  BSF    03.6
02F0:  MOVWF  0D
02F1:  BCF    03.6
02F2:  MOVF   41,W
02F3:  BSF    03.6
02F4:  MOVWF  0F
02F5:  BCF    03.6
02F6:  MOVF   0B,W
02F7:  MOVWF  42
02F8:  BCF    0B.7
02F9:  BSF    03.5
02FA:  BSF    03.6
02FB:  BSF    0C.7
02FC:  BSF    0C.0
02FD:  NOP
02FE:  NOP
02FF:  BCF    03.5
0300:  BCF    03.6
0301:  BTFSC  42.7
0302:  BSF    0B.7
0303:  DECFSZ 3E,F
0304:  GOTO   306
0305:  GOTO   325
0306:  BSF    03.6
0307:  RLF    0C,W
0308:  RLF    0E,W
0309:  ANDLW  7F
030A:  BCF    03.6
030B:  MOVWF  3F
030C:  BSF    03.6
030D:  MOVF   0D,W
030E:  BCF    03.6
030F:  MOVWF  40
0310:  BSF    03.6
0311:  MOVF   0F,W
0312:  BCF    03.6
0313:  MOVWF  41
0314:  MOVF   3F,W
0315:  MOVWF  4B
0316:  CALL   22B
0317:  MOVF   40,W
0318:  BSF    03.6
0319:  MOVWF  0D
031A:  BCF    03.6
031B:  MOVF   41,W
031C:  BSF    03.6
031D:  MOVWF  0F
031E:  INCF   0D,F
031F:  BTFSC  03.2
0320:  INCF   0F,F
0321:  BCF    03.0
0322:  BCF    03.6
0323:  DECFSZ 3E,F
0324:  GOTO   2CF
0325:  RETURN
0326:  BTFSC  03.1
0327:  GOTO   32B
0328:  MOVLW  53
0329:  MOVWF  04
032A:  BCF    03.7
032B:  CLRF   77
032C:  CLRF   78
032D:  CLRF   79
032E:  CLRF   7A
032F:  CLRF   53
0330:  CLRF   54
0331:  CLRF   55
0332:  CLRF   56
0333:  MOVF   52,W
0334:  IORWF  51,W
0335:  IORWF  50,W
0336:  IORWF  4F,W
0337:  BTFSC  03.2
0338:  GOTO   369
0339:  MOVLW  20
033A:  MOVWF  57
033B:  BCF    03.0
033C:  RLF    4B,F
033D:  RLF    4C,F
033E:  RLF    4D,F
033F:  RLF    4E,F
0340:  RLF    53,F
0341:  RLF    54,F
0342:  RLF    55,F
0343:  RLF    56,F
0344:  MOVF   52,W
0345:  SUBWF  56,W
0346:  BTFSS  03.2
0347:  GOTO   352
0348:  MOVF   51,W
0349:  SUBWF  55,W
034A:  BTFSS  03.2
034B:  GOTO   352
034C:  MOVF   50,W
034D:  SUBWF  54,W
034E:  BTFSS  03.2
034F:  GOTO   352
0350:  MOVF   4F,W
0351:  SUBWF  53,W
0352:  BTFSS  03.0
0353:  GOTO   363
0354:  MOVF   4F,W
0355:  SUBWF  53,F
0356:  MOVF   50,W
0357:  BTFSS  03.0
0358:  INCFSZ 50,W
0359:  SUBWF  54,F
035A:  MOVF   51,W
035B:  BTFSS  03.0
035C:  INCFSZ 51,W
035D:  SUBWF  55,F
035E:  MOVF   52,W
035F:  BTFSS  03.0
0360:  INCFSZ 52,W
0361:  SUBWF  56,F
0362:  BSF    03.0
0363:  RLF    77,F
0364:  RLF    78,F
0365:  RLF    79,F
0366:  RLF    7A,F
0367:  DECFSZ 57,F
0368:  GOTO   33B
0369:  MOVF   53,W
036A:  MOVWF  00
036B:  INCF   04,F
036C:  MOVF   54,W
036D:  MOVWF  00
036E:  INCF   04,F
036F:  MOVF   55,W
0370:  MOVWF  00
0371:  INCF   04,F
0372:  MOVF   56,W
0373:  MOVWF  00
0374:  RETURN
0375:  MOVF   04,W
0376:  MOVWF  43
0377:  MOVF   42,W
0378:  MOVWF  45
0379:  BTFSC  03.2
037A:  GOTO   394
037B:  MOVF   41,W
037C:  MOVWF  4E
037D:  MOVF   40,W
037E:  MOVWF  4D
037F:  MOVF   3F,W
0380:  MOVWF  4C
0381:  MOVF   3E,W
0382:  MOVWF  4B
0383:  CLRF   52
0384:  CLRF   51
0385:  MOVLW  20
0386:  MOVWF  50
0387:  MOVLW  82
0388:  MOVWF  4F
0389:  CALL   0BB
038A:  MOVF   7A,W
038B:  MOVWF  41
038C:  MOVF   79,W
038D:  MOVWF  40
038E:  MOVF   78,W
038F:  MOVWF  3F
0390:  MOVF   77,W
0391:  MOVWF  3E
0392:  DECFSZ 45,F
0393:  GOTO   37B
0394:  MOVF   41,W
0395:  MOVWF  4E
0396:  MOVF   40,W
0397:  MOVWF  4D
0398:  MOVF   3F,W
0399:  MOVWF  4C
039A:  MOVF   3E,W
039B:  MOVWF  4B
039C:  MOVF   4B,W
039D:  SUBLW  B6
039E:  MOVWF  4B
039F:  CLRF   7A
03A0:  MOVF   4C,W
03A1:  MOVWF  4F
03A2:  BSF    4C.7
03A3:  BCF    03.0
03A4:  RRF    4C,F
03A5:  RRF    4D,F
03A6:  RRF    4E,F
03A7:  RRF    7A,F
03A8:  RRF    79,F
03A9:  RRF    78,F
03AA:  RRF    77,F
03AB:  DECFSZ 4B,F
03AC:  GOTO   3A3
03AD:  BTFSS  4F.7
03AE:  GOTO   3BA
03AF:  COMF   77,F
03B0:  COMF   78,F
03B1:  COMF   79,F
03B2:  COMF   7A,F
03B3:  INCF   77,F
03B4:  BTFSC  03.2
03B5:  INCF   78,F
03B6:  BTFSC  03.2
03B7:  INCF   79,F
03B8:  BTFSC  03.2
03B9:  INCF   7A,F
03BA:  MOVF   7A,W
03BB:  MOVWF  41
03BC:  MOVF   79,W
03BD:  MOVWF  40
03BE:  MOVF   78,W
03BF:  MOVWF  3F
03C0:  MOVF   77,W
03C1:  MOVWF  3E
03C2:  BTFSS  41.7
03C3:  GOTO   3D1
03C4:  DECF   43,F
03C5:  BSF    43.5
03C6:  COMF   3E,F
03C7:  COMF   3F,F
03C8:  COMF   40,F
03C9:  COMF   41,F
03CA:  INCF   3E,F
03CB:  BTFSC  03.2
03CC:  INCF   3F,F
03CD:  BTFSC  03.2
03CE:  INCF   40,F
03CF:  BTFSC  03.2
03D0:  INCF   41,F
03D1:  MOVLW  3B
03D2:  MOVWF  4A
03D3:  MOVLW  9A
03D4:  MOVWF  49
03D5:  MOVLW  CA
03D6:  MOVWF  48
03D7:  CLRF   47
03D8:  MOVLW  0A
03D9:  MOVWF  45
03DA:  MOVF   42,W
03DB:  BTFSC  03.2
03DC:  INCF   43,F
03DD:  BSF    03.1
03DE:  MOVLW  3E
03DF:  MOVWF  04
03E0:  BCF    03.7
03E1:  MOVF   41,W
03E2:  MOVWF  4E
03E3:  MOVF   40,W
03E4:  MOVWF  4D
03E5:  MOVF   3F,W
03E6:  MOVWF  4C
03E7:  MOVF   3E,W
03E8:  MOVWF  4B
03E9:  MOVF   4A,W
03EA:  MOVWF  52
03EB:  MOVF   49,W
03EC:  MOVWF  51
03ED:  MOVF   48,W
03EE:  MOVWF  50
03EF:  MOVF   47,W
03F0:  MOVWF  4F
03F1:  CALL   326
03F2:  MOVF   78,W
03F3:  MOVF   77,F
03F4:  BTFSS  03.2
03F5:  GOTO   409
03F6:  INCF   42,W
03F7:  SUBWF  45,W
03F8:  BTFSC  03.2
03F9:  GOTO   409
03FA:  MOVF   43,W
03FB:  BTFSC  03.2
03FC:  GOTO   40B
03FD:  ANDLW  0F
03FE:  SUBWF  45,W
03FF:  BTFSC  03.2
0400:  GOTO   403
0401:  BTFSC  03.0
0402:  GOTO   43B
0403:  BTFSC  43.7
0404:  GOTO   43B
0405:  BTFSC  43.6
0406:  GOTO   40B
0407:  MOVLW  20
0408:  GOTO   437
0409:  MOVLW  20
040A:  ANDWF  43,F
040B:  BTFSS  43.5
040C:  GOTO   419
040D:  BCF    43.5
040E:  MOVF   42,W
040F:  BTFSS  03.2
0410:  DECF   43,F
0411:  MOVF   77,W
0412:  MOVWF  43
0413:  MOVLW  2D
0414:  MOVWF  4B
0415:  CALL   22B
0416:  MOVF   43,W
0417:  MOVWF  77
0418:  CLRF   43
0419:  MOVF   42,W
041A:  SUBWF  45,W
041B:  BTFSS  03.2
041C:  GOTO   427
041D:  MOVF   77,W
041E:  MOVWF  43
041F:  MOVLW  2E
0420:  MOVWF  4B
0421:  CALL   22B
0422:  MOVF   43,W
0423:  MOVWF  77
0424:  MOVLW  20
0425:  ANDWF  43,F
0426:  MOVLW  00
0427:  MOVLW  30
0428:  BTFSS  43.5
0429:  GOTO   437
042A:  BCF    43.5
042B:  MOVF   42,W
042C:  BTFSS  03.2
042D:  DECF   43,F
042E:  MOVF   77,W
042F:  MOVWF  43
0430:  MOVLW  2D
0431:  MOVWF  4B
0432:  CALL   22B
0433:  MOVF   43,W
0434:  MOVWF  77
0435:  CLRF   43
0436:  MOVLW  30
0437:  ADDWF  77,F
0438:  MOVF   77,W
0439:  MOVWF  4B
043A:  CALL   22B
043B:  BCF    03.1
043C:  MOVF   4A,W
043D:  MOVWF  4E
043E:  MOVF   49,W
043F:  MOVWF  4D
0440:  MOVF   48,W
0441:  MOVWF  4C
0442:  MOVF   47,W
0443:  MOVWF  4B
0444:  CLRF   52
0445:  CLRF   51
0446:  CLRF   50
0447:  MOVLW  0A
0448:  MOVWF  4F
0449:  CALL   326
044A:  MOVF   7A,W
044B:  MOVWF  4A
044C:  MOVF   79,W
044D:  MOVWF  49
044E:  MOVF   78,W
044F:  MOVWF  48
0450:  MOVF   77,W
0451:  MOVWF  47
0452:  DECFSZ 45,F
0453:  GOTO   3DD
0454:  RETURN
*
0585:  BCF    03.6
0586:  MOVF   0B,W
0587:  MOVWF  3E
0588:  BCF    0B.7
0589:  BSF    03.5
058A:  BSF    03.6
058B:  BSF    0C.7
058C:  BSF    0C.0
058D:  NOP
058E:  NOP
058F:  BCF    03.5
0590:  BCF    03.6
0591:  BTFSC  3E.7
0592:  BSF    0B.7
0593:  BSF    03.6
0594:  MOVF   0C,W
0595:  ANDLW  7F
0596:  BTFSC  03.2
0597:  GOTO   5D8
0598:  BCF    03.6
0599:  MOVWF  3E
059A:  BSF    03.6
059B:  MOVF   0D,W
059C:  BCF    03.6
059D:  MOVWF  3F
059E:  BSF    03.6
059F:  MOVF   0F,W
05A0:  BCF    03.6
05A1:  MOVWF  40
05A2:  MOVF   3E,W
05A3:  MOVWF  4B
05A4:  CALL   22B
05A5:  MOVF   3F,W
05A6:  BSF    03.6
05A7:  MOVWF  0D
05A8:  BCF    03.6
05A9:  MOVF   40,W
05AA:  BSF    03.6
05AB:  MOVWF  0F
05AC:  BCF    03.6
05AD:  MOVF   0B,W
05AE:  MOVWF  41
05AF:  BCF    0B.7
05B0:  BSF    03.5
05B1:  BSF    03.6
05B2:  BSF    0C.7
05B3:  BSF    0C.0
05B4:  NOP
05B5:  NOP
05B6:  BCF    03.5
05B7:  BCF    03.6
05B8:  BTFSC  41.7
05B9:  BSF    0B.7
05BA:  BSF    03.6
05BB:  RLF    0C,W
05BC:  RLF    0E,W
05BD:  ANDLW  7F
05BE:  BTFSC  03.2
05BF:  GOTO   5D8
05C0:  BCF    03.6
05C1:  MOVWF  3E
05C2:  BSF    03.6
05C3:  MOVF   0D,W
05C4:  BCF    03.6
05C5:  MOVWF  3F
05C6:  BSF    03.6
05C7:  MOVF   0F,W
05C8:  BCF    03.6
05C9:  MOVWF  40
05CA:  MOVF   3E,W
05CB:  MOVWF  4B
05CC:  CALL   22B
05CD:  MOVF   3F,W
05CE:  BSF    03.6
05CF:  MOVWF  0D
05D0:  BCF    03.6
05D1:  MOVF   40,W
05D2:  BSF    03.6
05D3:  MOVWF  0F
05D4:  INCF   0D,F
05D5:  BTFSC  03.2
05D6:  INCF   0F,F
05D7:  GOTO   585
....................  
.................... #list 
....................  
.................... #device adc = 10 //crea conversor  
.................... #fuses XT, NOWDT 
.................... #use delay (clock=4000000)//cristal 
*
0023:  MOVLW  4C
0024:  MOVWF  04
0025:  BCF    03.7
0026:  MOVF   00,W
0027:  BTFSC  03.2
0028:  GOTO   037
0029:  MOVLW  01
002A:  MOVWF  78
002B:  CLRF   77
002C:  DECFSZ 77,F
002D:  GOTO   02C
002E:  DECFSZ 78,F
002F:  GOTO   02B
0030:  MOVLW  4A
0031:  MOVWF  77
0032:  DECFSZ 77,F
0033:  GOTO   032
0034:  GOTO   035
0035:  DECFSZ 00,F
0036:  GOTO   029
0037:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0693:  BCF    03.5
0694:  CLRF   20
0695:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd_2D_puertoE.c>  // Librera para el manejo del lcd  1024 posiciones  
.................... // Funciones definidas en esta en esta libreria, las cuales podemos llamar desde nuestro programa principal. 
....................  
.................... //  lcd_init()   Inicializacin del LCD (debe utilizarse al principio, antes de trabajar con el LCD). 
.................... // 
.................... //  lcd_putc(c)  Saca un caracters en el LCD. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar LCD 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posicin. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el LCD. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del LCD. 
....................  
....................  
.................... #bit  lcd_enable = 9.2 
.................... #bit  lcd_rw     = 9.1 
.................... #bit  lcd_rs     = 9.0 
.................... #byte lcd_a = 5 
.................... #byte lcd_b = 6 
....................  
.................... #define LCD_LINEA2 0x40    // Direccion de memoria para la segunda linea 
.................... #define LCD_DATO    1 
.................... #define LCD_COMANDO 0 
....................  
.................... #define LCD_CLEAR        0x01 
.................... #define LCD_HOME    0x02 
....................  
.................... #define LCD_DISPLAY_OFF  0x08 
.................... #define LCD_DISPLAY_ON   0x0C 
.................... #define LCD_CURSOR_ON    0x0E 
.................... #define LCD_CURSOR_BLINK 0x0F 
....................  
.................... #define LCD_CURSOR_SHIFT_RIGHT  0x10 
.................... #define LCD_CURSOR_SHIFT_LEFT   0x14 
.................... #define LCD_DISPLAY_SHIFT_RIGHT 0x18 
.................... #define LCD_DISPLAY_SHIFT_LEFT  0x1C 
....................  
....................  
.................... int lcd_leer() 
.................... { 
....................   int valor; 
....................  
....................   set_tris_e(0x10); //tenia un 18 
*
003E:  BSF    03.5
003F:  BCF    09.0
0040:  BCF    09.1
0041:  BCF    09.2
....................   set_tris_b(0xFF); 
0042:  MOVLW  FF
0043:  MOVWF  06
....................  
....................   lcd_rw = 1; 
0044:  BCF    03.5
0045:  BSF    09.1
....................   delay_cycles(1); 
0046:  NOP
....................   lcd_enable = 1; 
0047:  BSF    09.2
....................   delay_cycles(1); 
0048:  NOP
....................   valor = lcd_b; 
0049:  MOVF   06,W
004A:  MOVWF  52
....................   lcd_enable = 0; 
004B:  BCF    09.2
....................   delay_us(40); 
004C:  MOVLW  0C
004D:  MOVWF  77
004E:  DECFSZ 77,F
004F:  GOTO   04E
0050:  GOTO   051
0051:  NOP
....................  
....................   set_tris_b(0x00); 
0052:  MOVLW  00
0053:  BSF    03.5
0054:  MOVWF  06
....................   return valor; 
0055:  BCF    03.5
0056:  MOVF   52,W
0057:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_enviar(int dir, int valor) 
.................... { 
....................   set_tris_a(0x00); 
*
0038:  MOVLW  00
0039:  BSF    03.5
003A:  MOVWF  05
....................   set_tris_b(0x00); 
003B:  MOVWF  06
....................  
....................   lcd_rs = 0; 
003C:  BCF    03.5
003D:  BCF    09.0
....................   while( bit_test(lcd_leer(),7) ); 
*
0058:  MOVF   78,W
0059:  MOVWF  52
005A:  BTFSC  52.7
005B:  GOTO   03E
....................   lcd_rs = dir; 
005C:  BTFSS  50.0
005D:  BCF    09.0
005E:  BTFSC  50.0
005F:  BSF    09.0
....................   delay_cycles(1); 
0060:  NOP
....................  
....................   lcd_rw = 0; 
0061:  BCF    09.1
....................   delay_cycles(1); 
0062:  NOP
....................   lcd_enable = 0; 
0063:  BCF    09.2
....................   lcd_b = valor; 
0064:  MOVF   51,W
0065:  MOVWF  06
....................   delay_cycles(1); 
0066:  NOP
....................   lcd_enable = 1; 
0067:  BSF    09.2
....................   delay_us(2); 
0068:  GOTO   069
....................   lcd_enable = 0; 
0069:  BCF    09.2
....................   delay_us(40); 
006A:  MOVLW  0C
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  GOTO   06F
006F:  NOP
0070:  RETURN
.................... } 
....................  
....................  
.................... void lcd_init() 
.................... { 
....................   int i; 
....................  
....................   set_tris_a(0x18); 
0071:  MOVLW  18
0072:  BSF    03.5
0073:  MOVWF  05
....................   set_tris_b(0x00); 
0074:  MOVLW  00
0075:  MOVWF  06
....................  
....................   lcd_enable = 0; 
0076:  BCF    03.5
0077:  BCF    09.2
....................   lcd_rw = 0; 
0078:  BCF    09.1
....................   lcd_rs = 0; 
0079:  BCF    09.0
....................   delay_ms(15); 
007A:  MOVLW  0F
007B:  MOVWF  4C
007C:  CALL   023
....................  
....................   for(i=0; i<3; i++) 
007D:  CLRF   3E
007E:  MOVF   3E,W
007F:  SUBLW  02
0080:  BTFSS  03.0
0081:  GOTO   08B
....................   { 
....................     lcd_enviar(LCD_COMANDO,0x38); 
0082:  CLRF   50
0083:  MOVLW  38
0084:  MOVWF  51
0085:  CALL   038
....................     delay_ms(5); 
0086:  MOVLW  05
0087:  MOVWF  4C
0088:  CALL   023
0089:  INCF   3E,F
008A:  GOTO   07E
....................   } 
....................   lcd_enviar(LCD_COMANDO,LCD_DISPLAY_ON); 
008B:  CLRF   50
008C:  MOVLW  0C
008D:  MOVWF  51
008E:  CALL   038
....................   lcd_enviar(LCD_COMANDO,0x06); 
008F:  CLRF   50
0090:  MOVLW  06
0091:  MOVWF  51
0092:  CALL   038
....................   lcd_enviar(LCD_COMANDO,LCD_CLEAR); 
0093:  CLRF   50
0094:  MOVLW  01
0095:  MOVWF  51
0096:  CALL   038
....................   lcd_enviar(LCD_COMANDO,LCD_HOME); 
0097:  CLRF   50
0098:  MOVLW  02
0099:  MOVWF  51
009A:  CALL   038
009B:  BCF    0A.3
009C:  BCF    0A.4
009D:  GOTO   6A4 (RETURN)
.................... } 
....................  
....................  
.................... void lcd_gotoxy( byte x, byte y) { 
....................    byte dir; 
....................  
....................    if(y!=1) 
*
0219:  DECFSZ 4D,W
021A:  GOTO   21C
021B:  GOTO   21F
....................      dir=LCD_LINEA2; 
021C:  MOVLW  40
021D:  MOVWF  4E
021E:  GOTO   220
....................    else 
....................      dir=0; 
021F:  CLRF   4E
....................    dir+=x-1; 
0220:  MOVLW  01
0221:  SUBWF  4C,W
0222:  ADDWF  4E,F
....................    lcd_enviar(LCD_COMANDO,0x80|dir); 
0223:  MOVF   4E,W
0224:  IORLW  80
0225:  MOVWF  4F
0226:  CLRF   50
0227:  MOVF   4F,W
0228:  MOVWF  51
0229:  CALL   038
022A:  RETURN
.................... } 
....................  
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
022B:  MOVF   4B,W
022C:  XORLW  0C
022D:  BTFSC  03.2
022E:  GOTO   236
022F:  XORLW  06
0230:  BTFSC  03.2
0231:  GOTO   23E
0232:  XORLW  02
0233:  BTFSC  03.2
0234:  GOTO   244
0235:  GOTO   249
....................      case '\f'   : lcd_enviar(LCD_COMANDO,0x01); 
0236:  CLRF   50
0237:  MOVLW  01
0238:  MOVWF  51
0239:  CALL   038
....................                    delay_ms(2); 
023A:  MOVLW  02
023B:  MOVWF  4C
023C:  CALL   023
....................                    break; 
023D:  GOTO   24E
....................      case '\n'   : lcd_gotoxy(1,2);               break; 
023E:  MOVLW  01
023F:  MOVWF  4C
0240:  MOVLW  02
0241:  MOVWF  4D
0242:  CALL   219
0243:  GOTO   24E
....................      case '\b'   : lcd_enviar(LCD_COMANDO,0x10);  break; 
0244:  CLRF   50
0245:  MOVLW  10
0246:  MOVWF  51
0247:  CALL   038
0248:  GOTO   24E
....................      default     : lcd_enviar(LCD_DATO,c);        break; 
0249:  MOVLW  01
024A:  MOVWF  50
024B:  MOVF   4B,W
024C:  MOVWF  51
024D:  CALL   038
....................    } 
024E:  RETURN
.................... } 
....................  
....................  
.................... char lcd_getc( int x, int y) { 
....................    char valor; 
....................  
....................     lcd_gotoxy(x,y); 
....................  
....................     lcd_rs = 1; 
....................     valor = lcd_leer(); 
....................     lcd_rs = 0; 
....................  
....................     return valor; 
.................... } 
....................  
....................  
.................... #include <kbd_2D.c> 
.................... // Funciones para la gestin de un teclado  4x4 
....................  
.................... // char kbd_getc()   Devuelve el cdigo ASCII de la tecla pulsada. 
.................... //         Si no se puls ninguna, devuelve 0. 
....................  
....................  
.................... // Conexiones del teclado. 
.................... /* 
....................             RB0 RB1 RB2 RB3 
....................              ^   ^   ^   ^ 
....................              |   |   |   | 
....................            |---|---|---|---| 
....................   RB4 ---> | 1 | 2 | 3 | F | 
....................            |---|---|---|---| 
....................   RB5 ---> | 4 | 5 | 6 | E | 
....................            |---|---|---|---| 
....................   RB6 ---> | 7 | 8 | 9 | D | 
....................            |---|---|---|---| 
....................   RB7 ---> | A | 0 | B | C | 
....................            |---|---|---|---| 
.................... */ 
....................  
.................... // Caracteres ASCII asociados a cada tecla: 
.................... char const KEYS[4][4] = {{'+','=','0','Y'}, 
....................                          {'-','9','8','7'}, 
....................                          {'*','6','5','4'}, 
....................                          {'/','3','2','1'}}; 
....................  
.................... #byte kbd_port_b = 6 
....................  
....................  
.................... char kbd_getc() 
.................... { 
....................   char tecla=0; 
....................   int f,c,t,i,j; 
....................  
....................   port_b_pullups(true); 
....................   set_tris_b(0b00001111); // RB7-RB4 salidas, RB3-RB0 entradas 
....................  
....................   for(f=0x10, i=0; i<4; f<<=1, i++) 
....................   { 
....................     for(c=0x01, j=0; j<4; c<<=1, j++) 
....................     { 
....................       kbd_port_b = ~f; 
....................       delay_cycles(1); 
....................       t = kbd_port_b & 0x0F; 
....................       t = ~(t | 0xF0); 
....................       if(t == c) 
....................       { 
....................         delay_ms(20); 
....................         tecla=KEYS[i][j]; 
....................         while(t==c) 
....................         { 
....................           restart_wdt(); 
....................           t = kbd_port_b & 0x0F; 
....................           t = ~(t | 0xF0); 
....................         } 
....................         break; 
....................       } 
....................     } 
....................     if(tecla) 
....................       break; 
....................   } 
....................  
....................   port_b_pullups(false); 
....................   return tecla; 
.................... } 
....................  
....................  
.................... #byte port_a=5 
.................... #byte port_b=6 
.................... #byte port_c=7 
.................... #byte port_d=8 
....................  
.................... int16 conv_1, conv_2, conv_3; //captura el valor del conversor 
.................... float volt_1, volt_2, volt_3; 
.................... int16 temp_1, temp_2, temp_3; 
....................  
.................... void show_temp(){ 
....................    set_adc_channel(0);     //habilita la salida 0 como lector 
*
0455:  MOVLW  00
0456:  MOVWF  78
0457:  MOVF   1F,W
0458:  ANDLW  C7
0459:  IORWF  78,W
045A:  MOVWF  1F
....................    delay_us(20);           //espera 
045B:  MOVLW  06
045C:  MOVWF  77
045D:  DECFSZ 77,F
045E:  GOTO   45D
045F:  NOP
....................    conv_1 = read_adc();    //conv_1 va a ser igual al valor del adc 
0460:  BSF    1F.2
0461:  BTFSC  1F.2
0462:  GOTO   461
0463:  BSF    03.5
0464:  MOVF   1E,W
0465:  BCF    03.5
0466:  MOVWF  26
0467:  MOVF   1E,W
0468:  MOVWF  27
....................    volt_1 = (5.0 * conv_1)/1024.0; 
0469:  MOVF   27,W
046A:  MOVWF  3F
046B:  MOVF   26,W
046C:  MOVWF  3E
046D:  CALL   09E
046E:  CLRF   4E
046F:  CLRF   4D
0470:  MOVLW  20
0471:  MOVWF  4C
0472:  MOVLW  81
0473:  MOVWF  4B
0474:  MOVF   7A,W
0475:  MOVWF  52
0476:  MOVF   79,W
0477:  MOVWF  51
0478:  MOVF   78,W
0479:  MOVWF  50
047A:  MOVF   77,W
047B:  MOVWF  4F
047C:  CALL   0BB
047D:  MOVF   7A,W
047E:  MOVWF  41
047F:  MOVF   79,W
0480:  MOVWF  40
0481:  MOVF   78,W
0482:  MOVWF  3F
0483:  MOVF   77,W
0484:  MOVWF  3E
0485:  MOVF   7A,W
0486:  MOVWF  45
0487:  MOVF   79,W
0488:  MOVWF  44
0489:  MOVF   78,W
048A:  MOVWF  43
048B:  MOVF   77,W
048C:  MOVWF  42
048D:  CLRF   49
048E:  CLRF   48
048F:  CLRF   47
0490:  MOVLW  89
0491:  MOVWF  46
0492:  CALL   130
0493:  MOVF   7A,W
0494:  MOVWF  2F
0495:  MOVF   79,W
0496:  MOVWF  2E
0497:  MOVF   78,W
0498:  MOVWF  2D
0499:  MOVF   77,W
049A:  MOVWF  2C
....................    temp_1 = volt_1*100; 
049B:  MOVF   2F,W
049C:  MOVWF  4E
049D:  MOVF   2E,W
049E:  MOVWF  4D
049F:  MOVF   2D,W
04A0:  MOVWF  4C
04A1:  MOVF   2C,W
04A2:  MOVWF  4B
04A3:  CLRF   52
04A4:  CLRF   51
04A5:  MOVLW  48
04A6:  MOVWF  50
04A7:  MOVLW  85
04A8:  MOVWF  4F
04A9:  CALL   0BB
04AA:  MOVF   7A,W
04AB:  MOVWF  41
04AC:  MOVF   79,W
04AD:  MOVWF  40
04AE:  MOVF   78,W
04AF:  MOVWF  3F
04B0:  MOVF   77,W
04B1:  MOVWF  3E
04B2:  CALL   1FA
04B3:  MOVF   79,W
04B4:  MOVWF  39
04B5:  MOVF   78,W
04B6:  MOVWF  38
....................     
....................    set_adc_channel(1); 
04B7:  MOVLW  08
04B8:  MOVWF  78
04B9:  MOVF   1F,W
04BA:  ANDLW  C7
04BB:  IORWF  78,W
04BC:  MOVWF  1F
....................    delay_us(20); 
04BD:  MOVLW  06
04BE:  MOVWF  77
04BF:  DECFSZ 77,F
04C0:  GOTO   4BF
04C1:  NOP
....................    conv_2 = read_adc(); 
04C2:  BSF    1F.2
04C3:  BTFSC  1F.2
04C4:  GOTO   4C3
04C5:  BSF    03.5
04C6:  MOVF   1E,W
04C7:  BCF    03.5
04C8:  MOVWF  28
04C9:  MOVF   1E,W
04CA:  MOVWF  29
....................    volt_2 = (5.0*conv_2)/1024.0; 
04CB:  MOVF   29,W
04CC:  MOVWF  3F
04CD:  MOVF   28,W
04CE:  MOVWF  3E
04CF:  CALL   09E
04D0:  CLRF   4E
04D1:  CLRF   4D
04D2:  MOVLW  20
04D3:  MOVWF  4C
04D4:  MOVLW  81
04D5:  MOVWF  4B
04D6:  MOVF   7A,W
04D7:  MOVWF  52
04D8:  MOVF   79,W
04D9:  MOVWF  51
04DA:  MOVF   78,W
04DB:  MOVWF  50
04DC:  MOVF   77,W
04DD:  MOVWF  4F
04DE:  CALL   0BB
04DF:  MOVF   7A,W
04E0:  MOVWF  41
04E1:  MOVF   79,W
04E2:  MOVWF  40
04E3:  MOVF   78,W
04E4:  MOVWF  3F
04E5:  MOVF   77,W
04E6:  MOVWF  3E
04E7:  MOVF   7A,W
04E8:  MOVWF  45
04E9:  MOVF   79,W
04EA:  MOVWF  44
04EB:  MOVF   78,W
04EC:  MOVWF  43
04ED:  MOVF   77,W
04EE:  MOVWF  42
04EF:  CLRF   49
04F0:  CLRF   48
04F1:  CLRF   47
04F2:  MOVLW  89
04F3:  MOVWF  46
04F4:  CALL   130
04F5:  MOVF   7A,W
04F6:  MOVWF  33
04F7:  MOVF   79,W
04F8:  MOVWF  32
04F9:  MOVF   78,W
04FA:  MOVWF  31
04FB:  MOVF   77,W
04FC:  MOVWF  30
....................    temp_2 = volt_2*100; 
04FD:  MOVF   33,W
04FE:  MOVWF  4E
04FF:  MOVF   32,W
0500:  MOVWF  4D
0501:  MOVF   31,W
0502:  MOVWF  4C
0503:  MOVF   30,W
0504:  MOVWF  4B
0505:  CLRF   52
0506:  CLRF   51
0507:  MOVLW  48
0508:  MOVWF  50
0509:  MOVLW  85
050A:  MOVWF  4F
050B:  CALL   0BB
050C:  MOVF   7A,W
050D:  MOVWF  41
050E:  MOVF   79,W
050F:  MOVWF  40
0510:  MOVF   78,W
0511:  MOVWF  3F
0512:  MOVF   77,W
0513:  MOVWF  3E
0514:  CALL   1FA
0515:  MOVF   79,W
0516:  MOVWF  3B
0517:  MOVF   78,W
0518:  MOVWF  3A
....................     
....................    set_adc_channel(2); 
0519:  MOVLW  10
051A:  MOVWF  78
051B:  MOVF   1F,W
051C:  ANDLW  C7
051D:  IORWF  78,W
051E:  MOVWF  1F
....................    delay_us(20); 
051F:  MOVLW  06
0520:  MOVWF  77
0521:  DECFSZ 77,F
0522:  GOTO   521
0523:  NOP
....................    conv_3 = read_adc(); 
0524:  BSF    1F.2
0525:  BTFSC  1F.2
0526:  GOTO   525
0527:  BSF    03.5
0528:  MOVF   1E,W
0529:  BCF    03.5
052A:  MOVWF  2A
052B:  MOVF   1E,W
052C:  MOVWF  2B
....................    volt_3 = (5.0*conv_3)/1024.0; 
052D:  MOVF   2B,W
052E:  MOVWF  3F
052F:  MOVF   2A,W
0530:  MOVWF  3E
0531:  CALL   09E
0532:  CLRF   4E
0533:  CLRF   4D
0534:  MOVLW  20
0535:  MOVWF  4C
0536:  MOVLW  81
0537:  MOVWF  4B
0538:  MOVF   7A,W
0539:  MOVWF  52
053A:  MOVF   79,W
053B:  MOVWF  51
053C:  MOVF   78,W
053D:  MOVWF  50
053E:  MOVF   77,W
053F:  MOVWF  4F
0540:  CALL   0BB
0541:  MOVF   7A,W
0542:  MOVWF  41
0543:  MOVF   79,W
0544:  MOVWF  40
0545:  MOVF   78,W
0546:  MOVWF  3F
0547:  MOVF   77,W
0548:  MOVWF  3E
0549:  MOVF   7A,W
054A:  MOVWF  45
054B:  MOVF   79,W
054C:  MOVWF  44
054D:  MOVF   78,W
054E:  MOVWF  43
054F:  MOVF   77,W
0550:  MOVWF  42
0551:  CLRF   49
0552:  CLRF   48
0553:  CLRF   47
0554:  MOVLW  89
0555:  MOVWF  46
0556:  CALL   130
0557:  MOVF   7A,W
0558:  MOVWF  37
0559:  MOVF   79,W
055A:  MOVWF  36
055B:  MOVF   78,W
055C:  MOVWF  35
055D:  MOVF   77,W
055E:  MOVWF  34
....................    temp_3 = volt_3*100; 
055F:  MOVF   37,W
0560:  MOVWF  4E
0561:  MOVF   36,W
0562:  MOVWF  4D
0563:  MOVF   35,W
0564:  MOVWF  4C
0565:  MOVF   34,W
0566:  MOVWF  4B
0567:  CLRF   52
0568:  CLRF   51
0569:  MOVLW  48
056A:  MOVWF  50
056B:  MOVLW  85
056C:  MOVWF  4F
056D:  CALL   0BB
056E:  MOVF   7A,W
056F:  MOVWF  41
0570:  MOVF   79,W
0571:  MOVWF  40
0572:  MOVF   78,W
0573:  MOVWF  3F
0574:  MOVF   77,W
0575:  MOVWF  3E
0576:  CALL   1FA
0577:  MOVF   79,W
0578:  MOVWF  3D
0579:  MOVF   78,W
057A:  MOVWF  3C
....................     
....................    /*----- -- IMPRESION DE PANTALLA ---------- */ 
....................        lcd_gotoxy(3,1); 
057B:  MOVLW  03
057C:  MOVWF  4C
057D:  MOVLW  01
057E:  MOVWF  4D
057F:  CALL   219
....................        lcd_putc("T-1    T-2    T-3"); 
0580:  MOVLW  04
0581:  BSF    03.6
0582:  MOVWF  0D
0583:  MOVLW  00
0584:  MOVWF  0F
....................        lcd_gotoxy(1,2); 
*
05D8:  MOVLW  01
05D9:  BCF    03.6
05DA:  MOVWF  4C
05DB:  MOVLW  02
05DC:  MOVWF  4D
05DD:  CALL   219
....................        printf(lcd_putc,"C:%Ld   C:%Ld   C:%Ld",conv_1,conv_2,conv_3); 
05DE:  MOVLW  43
05DF:  MOVWF  4B
05E0:  CALL   22B
05E1:  MOVLW  3A
05E2:  MOVWF  4B
05E3:  CALL   22B
05E4:  MOVLW  10
05E5:  MOVWF  04
05E6:  MOVF   27,W
05E7:  MOVWF  3F
05E8:  MOVF   26,W
05E9:  MOVWF  3E
05EA:  CALL   24F
05EB:  MOVLW  0F
05EC:  BSF    03.6
05ED:  MOVWF  0D
05EE:  MOVLW  00
05EF:  MOVWF  0F
05F0:  BSF    03.0
05F1:  MOVLW  05
05F2:  BCF    03.6
05F3:  MOVWF  3E
05F4:  CALL   2CF
05F5:  MOVLW  10
05F6:  MOVWF  04
05F7:  MOVF   29,W
05F8:  MOVWF  3F
05F9:  MOVF   28,W
05FA:  MOVWF  3E
05FB:  CALL   24F
05FC:  MOVLW  13
05FD:  BSF    03.6
05FE:  MOVWF  0D
05FF:  MOVLW  00
0600:  MOVWF  0F
0601:  BSF    03.0
0602:  MOVLW  05
0603:  BCF    03.6
0604:  MOVWF  3E
0605:  CALL   2CF
0606:  MOVLW  10
0607:  MOVWF  04
0608:  MOVF   2B,W
0609:  MOVWF  3F
060A:  MOVF   2A,W
060B:  MOVWF  3E
060C:  CALL   24F
....................        lcd_gotoxy(21,1); 
060D:  MOVLW  15
060E:  MOVWF  4C
060F:  MOVLW  01
0610:  MOVWF  4D
0611:  CALL   219
....................        printf(lcd_putc,"V:%f V:%f V:%f",volt_1,volt_2,volt_3); 
0612:  MOVLW  56
0613:  MOVWF  4B
0614:  CALL   22B
0615:  MOVLW  3A
0616:  MOVWF  4B
0617:  CALL   22B
0618:  MOVLW  89
0619:  MOVWF  04
061A:  MOVF   2F,W
061B:  MOVWF  41
061C:  MOVF   2E,W
061D:  MOVWF  40
061E:  MOVF   2D,W
061F:  MOVWF  3F
0620:  MOVF   2C,W
0621:  MOVWF  3E
0622:  MOVLW  02
0623:  MOVWF  42
0624:  CALL   375
0625:  MOVLW  20
0626:  MOVWF  4B
0627:  CALL   22B
0628:  MOVLW  56
0629:  MOVWF  4B
062A:  CALL   22B
062B:  MOVLW  3A
062C:  MOVWF  4B
062D:  CALL   22B
062E:  MOVLW  89
062F:  MOVWF  04
0630:  MOVF   33,W
0631:  MOVWF  41
0632:  MOVF   32,W
0633:  MOVWF  40
0634:  MOVF   31,W
0635:  MOVWF  3F
0636:  MOVF   30,W
0637:  MOVWF  3E
0638:  MOVLW  02
0639:  MOVWF  42
063A:  CALL   375
063B:  MOVLW  20
063C:  MOVWF  4B
063D:  CALL   22B
063E:  MOVLW  56
063F:  MOVWF  4B
0640:  CALL   22B
0641:  MOVLW  3A
0642:  MOVWF  4B
0643:  CALL   22B
0644:  MOVLW  89
0645:  MOVWF  04
0646:  MOVF   37,W
0647:  MOVWF  41
0648:  MOVF   36,W
0649:  MOVWF  40
064A:  MOVF   35,W
064B:  MOVWF  3F
064C:  MOVF   34,W
064D:  MOVWF  3E
064E:  MOVLW  02
064F:  MOVWF  42
0650:  CALL   375
....................        lcd_gotoxy(21,2); 
0651:  MOVLW  15
0652:  MOVWF  4C
0653:  MOVLW  02
0654:  MOVWF  4D
0655:  CALL   219
....................        printf(lcd_putc,"T:%Ld   T:%Ld   T:%Ld",temp_1,temp_2,temp_3); 
0656:  MOVLW  54
0657:  MOVWF  4B
0658:  CALL   22B
0659:  MOVLW  3A
065A:  MOVWF  4B
065B:  CALL   22B
065C:  MOVLW  10
065D:  MOVWF  04
065E:  MOVF   39,W
065F:  MOVWF  3F
0660:  MOVF   38,W
0661:  MOVWF  3E
0662:  CALL   24F
0663:  MOVLW  1A
0664:  BSF    03.6
0665:  MOVWF  0D
0666:  MOVLW  00
0667:  MOVWF  0F
0668:  BSF    03.0
0669:  MOVLW  05
066A:  BCF    03.6
066B:  MOVWF  3E
066C:  CALL   2CF
066D:  MOVLW  10
066E:  MOVWF  04
066F:  MOVF   3B,W
0670:  MOVWF  3F
0671:  MOVF   3A,W
0672:  MOVWF  3E
0673:  CALL   24F
0674:  MOVLW  1E
0675:  BSF    03.6
0676:  MOVWF  0D
0677:  MOVLW  00
0678:  MOVWF  0F
0679:  BSF    03.0
067A:  MOVLW  05
067B:  BCF    03.6
067C:  MOVWF  3E
067D:  CALL   2CF
067E:  MOVLW  10
067F:  MOVWF  04
0680:  MOVF   3D,W
0681:  MOVWF  3F
0682:  MOVF   3C,W
0683:  MOVWF  3E
0684:  CALL   24F
0685:  BCF    0A.3
0686:  BCF    0A.4
0687:  GOTO   6A5 (RETURN)
.................... } 
....................  
....................  
....................        
....................        
.................... void main(void) 
0688:  MOVF   03,W
0689:  ANDLW  1F
068A:  MOVWF  03
068B:  BSF    03.5
068C:  BSF    1F.0
068D:  BSF    1F.1
068E:  BSF    1F.2
068F:  BCF    1F.3
0690:  MOVLW  07
0691:  MOVWF  1C
0692:  BCF    03.7
.................... { 
....................    setup_adc_ports(RA0_RA1_RA3_ANALOG); //DEFINO LOS PUERTOS A UTILIZAR 
*
0696:  BSF    03.5
0697:  BCF    1F.0
0698:  BCF    1F.1
0699:  BSF    1F.2
069A:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
069B:  BCF    1F.6
069C:  BCF    03.5
069D:  BSF    1F.6
069E:  BSF    1F.7
069F:  BSF    03.5
06A0:  BSF    1F.7
06A1:  BCF    03.5
06A2:  BSF    1F.0
....................     
....................    lcd_init(); //inicializa lcd  
06A3:  GOTO   071
....................    while(TRUE){    
....................     //  test(); 
....................       show_temp(); 
06A4:  GOTO   455
....................       delay_ms(100); 
06A5:  MOVLW  64
06A6:  MOVWF  4C
06A7:  CALL   023
06A8:  GOTO   6A4
....................        
....................       
....................      } 
.................... } 
06A9:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
